# Queries for articles, slices, navigation, system information, media, languages, configs, modules, and templates
# nested relations are handled automatically by the resolver (currently only 2 levels deep - WIP)
type Query {
  # Retrieves a single article by ID, optionally filtered by language and content type
  article(id: ID!, clangId: ID, ctypeId: ID): article

  # Retrieves a list of articles with optional filters for language, content type, category, status, and pagination
  articles(
    clangId: ID
    ctypeId: ID
    categoryId: ID
    status: Boolean
    where: String
    orderBy: String
    offset: Int
    limit: Int
  ): [article]

  # Retrieves a single config by namespace and key
  config(namespace: String!, key: String!): config

  # Retrieves all configs for a given namespace
  configs(namespace: String!): [config]

  # Retrieves a single language by ID
  language(id: ID!): language

  # Retrieves all languages
  languages: [language]

  # Retrieves a single media item by ID
  media(id: ID!): media

  # Retrieves a list of media items filtered by category ID
  medias(categoryId: ID): [media]

  # Retrieves a single media category by ID
  mediaCategory(id: ID!): mediaCategory

  # Retrieves media categories, optionally filtered by parent ID or path
  mediaCategories(parentId: ID, path: String): [mediaCategory]

  # Retrieves a single module by ID or key
  module(id: ID, key: String): module

  # Retrieves all modules
  modules: [module]

  # Retrieves a navigation structure based on category ID, language ID, depth, and whether to nest items
  navigation(
    categoryId: ID
    clangId: ID
    depth: ID
    nested: Boolean
  ): [navigationItem]

  # Retrieves all routes defined in the system, if URL package is installed,
  # this will return the routes defined in the URL package
  routes: [route]

  # Retrieves a single article slice by ID
  slice(id: ID!): slice

  # Retrieves slices of an article by article ID, optionally filtered by language and content type
  slices(articleId: ID!, clangId: ID, ctypeId: ID): [slice]

  # Retrieves system information, such as server details, version, and domain settings
  system(host: String): system!

  # Retrieves a single template by ID or key
  template(id: ID, key: String): template

  # Retrieves all templates, optionally filtered by active status
  templates(active: Boolean): [template]

  # Retrieves a single wildcard by wildcard string, language ID, and ID
  wildcard(wildcard: String, clangId: ID, id: ID): wildcard

  # Retrieves all wildcards, optionally filtered by language ID
  wildcards(clangId: ID): [wildcard]
}

type article {
  id: ID!
  name: String
  slug: String
  priority: Int
  catPriority: Int
  status: Boolean
  parentId: ID
  parent: article
  clangId: ID
  language: language
  templateId: ID
  startarticle: Boolean
  createdate: String
  updatedate: String
  yrewriteUrlType: String
  yrewriteUrl: String
  yrewriteRedirection: String
  yrewriteTitle: String
  yrewriteDescription: String
  yrewriteImage: String
  yrewriteIndex: Boolean
  slices: [slice]
  template: template
}

type config {
  namespace: String
  key: String
  value: String
}

type language {
  id: ID!
  name: String
  code: String
  status: Boolean
}

type media {
  id: ID!
  filename: String
  name: String
  categoryId: Int
  filesize: Int
  width: Int
  height: Int
  filetype: String
  focus: String
  createdate: String
  updatedate: String
  category: mediaCategory
}

type mediaCategory {
  id: ID!
  name: String
  parentId: ID
  createdate: String
  updatedate: String
  medias: [media]
  children: [mediaCategory]
}

type module {
  id: ID
  key: String
  name: String
  slices: [slice]
}

type navigationItem {
  id: ID!
  name: String
  parentId: ID
  slug: String
  children: [navigationItem]
}

type route {
  id: ID!
  parentId: ID
  parent: article
  routeType: String
  urlProfile: String
  status: Boolean
  slug: String
  name: String
  description: String
  clangId: ID
  language: language
  startarticle: Boolean
  createdate: String
  updatedate: String
  image: String
  index: Boolean
}

type slice {
  id: ID
  articleId: ID
  article: article
  moduleId: ID
  module: module
  ctypeId: ID
  clangId: ID
  language: language
  priority: Int
  status: Boolean
  value1: String
  value2: String
  value3: String
  value4: String
  value5: String
  value6: String
  value7: String
  value8: String
  value9: String
  value10: String
  value11: String
  value12: String
  value13: String
  value14: String
  value15: String
  value16: String
  value17: String
  value18: String
  value19: String
  value20: String
  media1: String
  media2: String
  media3: String
  media4: String
  media5: String
  media6: String
  media7: String
  media8: String
  media9: String
  media10: String
  medialist1: String
  medialist2: String
  medialist3: String
  medialist4: String
  medialist5: String
  medialist6: String
  medialist7: String
  medialist8: String
  medialist9: String
  medialist10: String
  link1: String
  link2: String
  link3: String
  link4: String
  link5: String
  link6: String
  link7: String
  link8: String
  link9: String
  link10: String
  linklist1: String
  linklist2: String
  linklist3: String
  linklist4: String
  linklist5: String
  linklist6: String
  linklist7: String
  linklist8: String
  linklist9: String
  linklist10: String
  createdate: String
  updatedate: String
}

type system {
  server: String
  serverName: String
  errorEmail: String
  version: String
  startArticleId: ID
  notFoundArticleId: ID
  defaultTemplateId: ID
  domainHost: String
  domainUrl: String
  domainStartId: ID
  domainNotfoundId: ID
  domainLanguages: [language]
  domainDefaultLanguage: language
  startClangHidden: Boolean
}

type template {
  id: ID!
  name: String
  key: String
  active: Boolean
  createdate: String
  updatedate: String
  content: String
  articles: [article]
}

type wildcard {
  id: ID!
  wildcard: String
  value: String
  clangId: ID
  createdate: String
  updatedate: String
}
